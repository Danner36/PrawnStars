//LIBRARIES

#include "init.h"
#include "uart.h" //Lab 5
#include "wifi.h"
#include "adc.h" //Lab 6
#include "sonar.h" //Lab 7
#include "servo.h" //Lab 8
#include <string.h>
#include <inc/tm4c123gh6pm.h>
#include "driverlib/interrupt.h"
#include <stdio.h>
#include <math.h>



//FUNCTION PROTOTYPES

float calculateLinearWidth(int angle, float distance);
void collectData();
int getAverge(int array[]);
float getIRtoDis(float result);
int getSmallest(int array[]);
int getSmallestIndex(int array[]);
void initialize();
void resetTempVars();
void sendData(int i);
void sendHeader();




//GLOBAL VARIABLES

//Counter to keep track of detected objects.
char numObjects = 0;

//Beginning angle, ending angle, and the total angle width of the object.
int angle1 = 0, angle2 = 0, totalAngle = 0;

//Holds the current cycles Sonar Distance.
float sonarDis = 0.0;

//Holds the current cycles IR Distance.
float irDis = 0.0;

//Once an object is detected, this value is compounded with each cycles's
//   distance. This is used to calculate the average.
float totalDis = 0.0;

//Value used to move the servo.
int pulse_period = 0;

//Once an object is detected, this value will increment by one with every
//   cycle. This is used to keep track of how many degrees the object was
//   was detected for.
float cyclesDetected = 0.0;

struct Smallest{
    int index;
    int degree;
    int angle;
    float linearWidth;
    float distance;
};
struct Smallest Comparator;

//Used to keep track of this projects status as a state machine.
enum status {NONE , DETECTED, SCANNING};
enum status STATE = NONE;



//FUNCTIONS AND METHODS

/**
 * MAIN PROGRAM. Runs loop, collects data, performs calculations, and transmits data.
 */
void main() {

    //Initializes all devices and variables.
    initialize();

    int i = 0;
    //Main loop. Iterates servo from degree 0 to 180 while capturing data. Also
    //   performs calculations and transmits useful info to Putty via WiFi.
    for (i = 0; i < 180; i += 2) {

        //Moves the servo two degrees.
        pulse_period += DEGREE;
        move_servo(pulse_period);

        pulse_period += DEGREE;
        move_servo(pulse_period);

        //Collects data from both IR & Sonar sensors.
        collectData();

        //Sends the current most cycles data to Putty.
        sendData(i);

        //Object has been detected. Updates state machine.
        if ((STATE == NONE) && ((irDis < 100) && (sonarDis < 100))) {

            //Object has been detected. Updates state machine.
            STATE = DETECTED;

            //Captures the angle at which the object is first detected.
            angle1 = i;

            //Increments the number of objects detected by 1.
            numObjects++;

            //Used in the calculation of where the current object is located.
            totalDis += sonarDis;

            //Used to later calculate the average distance.
            //   (number of cycles the object is in sight)
            cyclesDetected++;

        }

        //Object is still being detected. Continues to read in data.
        else if((STATE == DETECTED) && ((irDis < 100) && (sonarDis < 100))){

            //Updates state machine to reflect the current situation.
            STATE = SCANNING;

            //Updates the current distance of the object in case the object is no longer detected
            //   next cycle.
            totalDis += sonarDis;

            //Used to later calculate the average distance.
            //   (number of cycles the object is in sight)
            cyclesDetected++;

        }

        //Object has been lost. Current data shows no object within 100cm.
        else if ( /*(STATE == DETECTED || */ STATE == SCANNING /*)*/ && (irDis > 100 || sonarDis > 100)) {

            int angleCalibration = 2;

            //Captures the angle at which the object is last detected.
            angle2 = i;

            //Calculates the total angle width of the object.
            //   - 2  <- moves the degree back to when the object was detected. (ending degree)
            //   / 2  <- gets the average of the two angles. (degree location of object)
            int degreeOfObject = ((angle1 + angle2)/2) - angleCalibration;

            //Calculates the average distance to the object.
            float objectDis = (totalDis / cyclesDetected);

            //Calculate the angle of the object.
            int objectAngle = ((angle2 - angle1) - 2);

            float objectWidth = calculateLinearWidth(objectAngle, objectDis);

            //Compares this object to that of the last object.
            if (numObjects == 1) {
                Comparator.degree = degreeOfObject;
                Comparator.angle = objectAngle;
                Comparator.distance = objectDis;
                Comparator.linearWidth = objectWidth;
            }
            else if (numObjects != 1 && ( objectWidth < Comparator.linearWidth /*objectAngle < Comparator.angle */)) {
                Comparator.index = Comparator.index + 1;
                Comparator.degree = degreeOfObject;
                Comparator.angle = objectAngle;
                Comparator.distance = objectDis;
                Comparator.linearWidth = objectWidth;
            }

            //Resets temporary variables.
            resetTempVars();
        }
    }

    //Prints the overall results of the scan to the robots lcd screen.
    //lcd_printf("Object Num: %d\nShortest Distance: %0.2f\nObject Angle: %d", numObjects, Comparator.distance, Comparator.angle);

    //lcd_printf("Objects: %d\nIndex: %d", numObjects, Comparator.index);

    char data[50];
    sprintf(data, "\n\rObjects: %d\n\rIndex: %d\n\rWidth: %0.2f", numObjects, Comparator.index, Comparator.linearWidth);

    uart_sendChar('\r');

    int j = 0;
    for(j = 0; j < strlen(data); j++) {
        uart_sendChar(data[j]);
    }

    uart_sendChar('\n');

    //Moves the servo to the position of the smallest object.
    int calibration = 6;
    move_servo(PERIOD + CW + ((Comparator.degree-calibration) * DEGREE)); //ABK - we want the degree, not the angular size

    //Waits for servo to complete turn before power off and or stall.
    timer_waitMillis(1000);
}



//HELPER METHODS

float calculateLinearWidth(int angle, float distance) {
    return distance * sinf((float)angle/2.0);
}

/**
 * Collects data from both Sonar and IR sensors.
 */
void collectData(){
    sonarDis = ping_read();
    irDis = getIRtoDis((float)adc_Read());
}


/**
 * Calculates and returns the average of the passed in array.
 */
int getAverage(int array[]) {

    int i, sum = 0;

    for (i = 0; i < sizeof(array)/4; i++) {
        if (array[i] == 0){
            break;
        }
        else{
            sum += array[i];
        }
    }

    return (sum / i);
}


/**
 * Calculates the conversion from IR input to distance.
 */
float getIRtoDis(float result){
    return (float)(1.682* pow(10,7))/(pow(result,500/239)) + 10;
}


/**
 * Initializes all peripherals and resets the position of the device.
 */
void initialize(){

    portB_init();
    adc_init();
    lcd_init();
    uart_init();

    Comparator.index = 0;

    //Enables WiFi.
    //int established = WiFi_start("password");
    //timer_waitMillis(10000);

    //Checks if WiFi has completed initialization.
    //WiFi_Check(established);

    //Resets the servo's position to zero degrees (Far right).
    pulse_period = PERIOD + CW;
    move_servo(pulse_period);

    //1.5 second delay to ensure servo reaches the 0th degree.
    timer_waitMillis(1500);

    //Sends the header information to Putty.
    sendHeader();
}


/**
 * Resets temporary variables.
 */
void resetTempVars(){

    cyclesDetected = 0.0;
    totalDis = 0.0;
    angle1 = 0;
    angle2 = 0;

    //Back to default state
    STATE = NONE;
}


/**
 * Sends current information to Putty.
 */
void sendData(int i){
    char data[50];
    sprintf(data, "%i\t\t%0.1f\t\t\t%0.2f\t\t%0.2f", i, irDis, sonarDis, Comparator.linearWidth);

    uart_sendChar('\r');

    int j = 0;
    for(j = 0; j < strlen(data); j++) {
       uart_sendChar(data[j]);
    }

    uart_sendChar('\n');
}


/**
 * Sends Header information to Putty.
 */
void sendHeader(){

    char* header = "Degrees\t\tIR Distance (cm)\tSonar Distance (cm)\tWidth";

    //Resets the position of the cursor to 2 lines below and the beginning of the line.
    uart_sendChar('\n');
    uart_sendChar('\n');
    uart_sendChar('\r');


    int i = 0;
    //Iterators through the array, sends each character to Putty via WiFi.
    for(i = 0; i < strlen(header); i++){
        uart_sendChar(header[i]);
    }

    //New lines.
    uart_sendChar('\n');
    uart_sendChar('\n');
}
