#include "init.h"
#include "uart.h" //Lab 5
#include "wifi.h"
#include "adc.h" //Lab 6
#include "sonar.h" //Lab 7
#include "servo.h" //Lab 8
#include <string.h>

#include <inc/tm4c123gh6pm.h>
#include "driverlib/interrupt.h"

#include <stdio.h>

//Misc prototypes
float distanceIRConversion (float result);

int average(int array[]);
int findSmallest(int array[]);

void main() {

    //INITIALIZATIONS
    init_All();
    adc_init();
    lcd_init();

    uart_init();
    //WiFi_start("password");

    //Reset to 180 degrees.
    int pulse_period = PERIOD + CW;
    move_servo(pulse_period);
    timer_waitMillis(1500);

    char* header = "Degrees\t\tIR Distance (cm)\tSonar Distance (cm)";


    //Sends the header.
    uart_sendChar('\n'); //Space apart from last run
    uart_sendChar('\n');
    uart_sendChar('\r');

    int i = 0;
    for(i = 0; i < strlen(header); i++){
        uart_sendChar(header[i]);
    }

    //Spacing
    uart_sendChar('\n');
    uart_sendChar('\n');

    //Sonar and IR data
    //Keep count of distinct objects detected
    char numObjects = 0;
    //Gathering data on obstacle
    char scanning = 0;

    int data_Sonar[90];
    int data_IR[90];

    //Smallest object
    //starting and ending angles
    int angle1 = 0, angle2 = 0, totalAngle = 0;
    //sonar distances
    int distances[50];
    //collection of rough distance for each detected object
    int distanceAverages[50];
    //measurement number, increment every 2 degrees
    int distanceIndex = 0, averageIndex = 0;
    //Holds the pulse period of each index object. Used to turn back to the smallest object.
    int degreeOfObject[50];
    //Iterator used for degreeOfObject
    int degreeIter = 0;
    //soi = smallest object index
    int soi = 0;

    //Initial array setting
    for (i = 0; i < 50; i++) {
        distances[i] = 0;
        distanceAverages[i] = 0;
        degreeOfObject[i] = 0;
    }

    //Turn 180 degrees, CW
    for (i = 0; i < 180; i += 2, distanceIndex++) {
        int index = i / 2;

        //DATA COLLECTION
        float distanceSonar = ping_read();
        float distanceIR = distanceIRConversion((float)adc_Read());

        data_Sonar[index] = (int)distanceSonar;
        data_IR[index] = (int)distanceIR;

        //SERVO ADJUSTMENT
        pulse_period += DEGREE*2;
        move_servo(pulse_period);

        //SEND DATA to PUTTY
        char data[50];
        sprintf(data, "%i\t\t%0.1f\t\t\t%0.2f", i, distanceIR, distanceSonar);

        uart_sendChar('\r');

        int j = 0;
        for(j = 0; j < strlen(data); j++) {
           uart_sendChar(data[j]);
        }

        uart_sendChar('\n');

        //DATA ANALYSIS
        if (i != 0) { //Won't work on first measurement

            //IR closer target start scanning
            if (scanning == 0 && data_IR[index - 1] - 100 > distanceIR) {

                scanning = 1; //start scanning
                angle1 = i; //record first angle
                numObjects++; //increment number of objects detected
                degreeOfObject[degreeIter] = pulse_period;

                degreeIter++;
                distanceIndex = 0;
            }

            //IR past original obstacle
            if (scanning == 1 && distanceIR - 100 > data_IR[index-1]) {

                angle2 = i; //record last angle
                totalAngle = angle2 - angle1;
                scanning = 0; //stop scanning

                //Calculate distance average
                distanceAverages[averageIndex] = average(distances);
                averageIndex++;

                //Reset distance collection array
                int k;
                for (k = 0; k < 50; k++) {
                    distances[k] = 0;
                }
            }
        }

        //distance collection
        if (scanning == 1) {
            distances[distanceIndex] = distanceSonar;
        }

        //Wait for interrupt
        timer_waitMillis(50);
    }

    //Scan Complete, print results
    lcd_printf("Object Num: %d\nSmallest: %d", numObjects, findSmallest(distanceAverages));

    //Turn toward smallest object.
    move_servo(degreeOfObject[findSmallest(distanceAverages)]);

    //Waits for servo to complete turn before power off and or stall.
    timer_waitMillis(100);
}

float distanceIRConversion (float result) {
    return (float)(1.682* pow(10,7))/(pow(result,500/239)) + 10;
}

int average(int array[]) {

    int i, sum = 0;

    for (i = 0; i < sizeof(array)/4; i++) {
        if (array[i] == 0){
            break;
        }
        else{
            sum += array[i];
        }
    }

    return (sum / i);
}

int findSmallest(int array[]) {
    int i, temp = array[0];

    for (i = 1; i < sizeof(array)/4; i++) {
        if (array[i] == 0){
            continue;
        }
        if (array[i] < temp){
            temp = array[i];
        }
    }

    return temp;
}
