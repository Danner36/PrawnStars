#include "init.h"
#include "uart.h" //Lab 5
#include "wifi.h"
#include "adc.h" //Lab 6
#include "sonar.h" //Lab 7
#include "servo.h" //Lab 8
#include <string.h>

#include <inc/tm4c123gh6pm.h>
#include "driverlib/interrupt.h"

#include <stdio.h>

//Misc prototypes
float distanceIRConversion (float result);

int average(int array[]);
int findSmallest(int array[]);
int findSmallestIndex(int array[]);

void main() {

    //INITIALIZATIONS
    init_All();
    adc_init();
    lcd_init();

    uart_init();
    WiFi_start("password");

    //Reset to 0 degrees.
    int pulse_period = PERIOD + CW;
    move_servo(pulse_period);
    timer_waitMillis(1500);

    char* header = "Degrees\t\tIR Distance (cm)\tSonar Distance (cm)";

    //Sends the header.
    uart_sendChar('\n'); //Space apart from last run
    uart_sendChar('\n');
    uart_sendChar('\r');

    int i = 0;
    for(i = 0; i < strlen(header); i++){
        uart_sendChar(header[i]);
    }

    //Spacing
    uart_sendChar('\n');
    uart_sendChar('\n');

    //Sonar and IR data
    //Keep count of distinct objects detected
    char numObjects = 0;
    //Gathering data on obstacle
    char scanning = 0;

    int data_Sonar[90];
    int data_IR[90];

    //Smallest object
    //starting and ending angles
    int angle1 = 0, angle2 = 0, totalAngle = 0;
    //sonar distances
    int distances[50];
    //collection of rough distance for each detected object
    int distanceAverages[50];
    //measurement number, increment every 2 degrees
    int distanceIndex = 0, averageIndex = 0;
    //Holds the pulse period of each index object. Used to turn back to the smallest object.
    int degreeOfObject[50];
    //Angular Size
    int angularSize[50];
    //Iterator used for degreeOfObject
    int degreeIter = 0;

    //Initial array setting
    for (i = 0; i < 50; i++) {
        distances[i] = 0;
        distanceAverages[i] = 0;
        degreeOfObject[i] = 0;
        angularSize[i] = 0;
    }

    //Turn 180 degrees, CW
    for (i = 0; i <= 180; i += 2, distanceIndex++) {
        int index = i / 2;

        //DATA COLLECTION
        float distanceSonar = ping_read();
        float distanceIR = distanceIRConversion((float)adc_Read());

        data_Sonar[index] = (int)distanceSonar;
        data_IR[index] = (int)distanceIR;

        //SERVO ADJUSTMENT
        pulse_period += DEGREE*2;
        move_servo(pulse_period);

        //SEND DATA to PUTTY
        char data[50];
        sprintf(data, "%i\t\t%0.1f\t\t\t%0.2f", i, distanceIR, distanceSonar);

        uart_sendChar('\r');

        int j = 0;
        for(j = 0; j < strlen(data); j++) {
           uart_sendChar(data[j]);
        }

        uart_sendChar('\n');

        //DATA ANALYSIS

        //IR closer target start scanning
        if ((distanceIR < 100) && (distanceSonar < 100) && (scanning == 0 || scanning == 3)) {

            scanning = 1; //start scanning
            angle1 = i; //record first angle
            numObjects++; //increment number of objects detected

            distanceIndex = 0;

        }

        //IR past original obstacle
        else if (scanning == 2 && (distanceIR > 87 || distanceIR < 35)) {

            angle2 = i; //record last angle
            totalAngle = angle2 - angle1;
            scanning = 0; //stop scanning

            degreeOfObject[degreeIter] = ((angle1 + angle2)/2) - 2;
            angularSize[degreeIter] = totalAngle;

            //Calculate distance average
            distanceAverages[averageIndex] = average(distances);
            averageIndex++;

            //Reset distance collection array
            int k;
            for (k = 0; k < 50; k++) {
                distances[k] = 0;
            }

            degreeIter++;

            uart_sendChar('\n');
        }

        //distance collection
        if (scanning == 3) {
            distances[distanceIndex] = distanceSonar;
        }

        //Pause between servo movements
        timer_waitMillis(50);
    }

    //Scan Complete, print results
    lcd_printf("Object Num: %d\nSmallest: %d", numObjects, findSmallestIndex(angularSize));

    //Turn toward smallest object.
    int temp = degreeOfObject[findSmallestIndex(angularSize)];

    //Calculate final move
    move_servo(PERIOD + CW + (temp*DEGREE));

    //Waits for servo to complete turn before power off and or stall.
    timer_waitMillis(1000);
}



float distanceIRConversion (float result) {
    return (float)(1.682* pow(10,7))/(pow(result,500/239)) + 10;
}



int average(int array[]) {

    int i, sum = 0;

    for (i = 0; i < sizeof(array)/4; i++) {
        if (array[i] == 0){
            break;
        }
        else{
            sum += array[i];
        }
    }

    return (sum / i);
}



int findSmallest(int array[]) {
    int i, temp = array[0];

    for (i = 1; i < sizeof(array)/4; i++) {
        if (array[i] == 0) {
            continue;
        }
        if (array[i] < temp) {
            temp = array[i];
        }
    }

    return temp;
}



int findSmallestIndex(int array[]) {
    int i, temp = 0;

    for (i = 1; i < sizeof(array)/4; i++) {
        if (array[i] == 0) {
            continue;
        }
        if (array[i] < temp) {
            temp = i;
        }
    }

    return temp;
}
